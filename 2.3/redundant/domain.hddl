(define (domain multi-robot-hierarchical)
    (:requirements :strips :typing :hierarchy :method-preconditions)

    (:types
        robot pod location artifact artifact-type - object
    )

    (:predicates
        (robot-at ?r - robot ?l - location)
        (can-access ?r - robot ?l - location)
        (can-pickup ?r - robot ?at - artifact-type)
        
        (artifact-at ?a - artifact ?l - location)
        (is-type ?a - artifact ?t - artifact-type)
        (assigned-target ?a - artifact ?target - location)
    )

    ;; ========================
    ;; ABSTRACT TASKS
    ;; ========================

    (:task process-room
        :parameters (?room - location)
    )
    
    (:task deliver
        :parameters (?a - artifact ?at - artifact-type ?target - location)
    )

    ;; ========================
    ;; METHODS
    ;; ========================

    (:method m_process_room_next
        :parameters (?room - location ?a - artifact ?at - artifact-type ?target - location)
        :task (process-room ?room)
        :precondition (and
            (artifact-at ?a ?room)
            (is-type ?a ?at)
            (assigned-target ?a ?target)
            (not (artifact-at ?a ?target)) 
        )
        :ordered-subtasks (and
            (t1 (deliver ?a ?at ?target))
            (t2 (process-room ?room))
        )
    )

    (:method m_process_room_done
        :parameters (?room - location)
        :task (process-room ?room)
        :ordered-subtasks () 
    )

    ;; --- IL METODO MANCANTE ---
    ;; Questo serve a "trovare" un robot (?r) e la posizione attuale dell'artefatto (?curr_loc)
    ;; per poi passare tutti i dati corretti all'azione primitiva.
    (:method m_deliver_direct
        :parameters (?a - artifact ?at - artifact-type ?target - location ?r - robot ?curr_loc - location)
        :task (deliver ?a ?at ?target)
        :precondition (and
            (artifact-at ?a ?curr_loc)
            
            (can-pickup ?r ?at)
            (can-access ?r ?curr_loc)
            (can-access ?r ?target)
        )
        :ordered-subtasks (and
            ;; Passiamo tutti i 5 parametri necessari all'azione
            (t1 (delivery ?r ?a ?curr_loc ?target ?at)) 
        )
    )

    (:method m_deliver_relay
        :parameters (?a - artifact ?at - artifact-type ?target - location 
                     ?r1 - robot ?r2 - robot 
                     ?curr_loc - location ?mid_loc - location)
        :task (deliver ?a ?at ?target)
        :precondition (and
            (artifact-at ?a ?curr_loc)
            
            ;; R1 prende e porta a metà
            (can-pickup ?r1 ?at)           
            (can-access ?r1 ?curr_loc)     
            (can-access ?r1 ?mid_loc)      
            (not (= ?curr_loc ?mid_loc)) ;; R1 deve muoverlo

            ;; R2 prende e porta alla fine
            (can-pickup ?r2 ?at)
            (can-access ?r2 ?mid_loc)      
            (can-access ?r2 ?target)       
            (not (= ?mid_loc ?target)) ;; R2 deve muoverlo

            ;; Usa staffetta solo se R1 non può arrivare dritto
            (not (can-access ?r1 ?target))
        )
        :ordered-subtasks (and
            (t1 (delivery ?r1 ?a ?curr_loc ?mid_loc ?at)) 
            (t2 (delivery ?r2 ?a ?mid_loc ?target ?at)) 
        )
    )

    ;; ========================
    ;; ACTIONS (Primitive)
    ;; ========================

    (:action delivery
        ;; Ho aggiunto ?at nei parametri per poterlo usare in (can-pickup)
        :parameters (?r - robot ?a - artifact ?from - location ?to - location ?at - artifact-type)
        :precondition ( )
        :effect (and
            (not (artifact-at ?a ?from))
            (artifact-at ?a ?to)
        )
    )
)