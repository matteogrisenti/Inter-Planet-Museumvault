# üìÇ PRP Planner Output Documentation

This document describes the files generated by the execution of the **PRP (Planner for Relevant Policies)**. Unlike classical planners that produce a simple list of actions, PRP generates a **Policy** capable of handling non-determinism (uncertainty) and failure.

**üîó Official Repository:** [https://github.com/QuMuLab/planner-for-relevant-policies](https://github.com/QuMuLab/planner-for-relevant-policies)

---

## üèÜ Core Output (The Solution)

PRP produces two distinct types of solution files. It is crucial to understand the difference between them to correctly interpret the robot's behavior.

### 1. `policy.out` (The True Solution)
* **Type:** **Strong Cyclic Policy**
* **Description:** This is the actual "brain" of the robot. Instead of a linear sequence of steps, it is a **Decision Tree** (or Lookup Table) that maps every reachable state to a specific action.
* **Key Feature (The Loop):** This policy handles non-determinism. If an action fails (e.g., `try-to-enter-seismic-room` fails and the robot stays in the tunnel), the policy detects the resulting state and commands the robot to **retry the action**. This creates the guaranteed "Strong Cyclic" solution loop.
* **Formats:**
    * **Raw:** Internal "Switch Graph" format (`switch x`, `check y`...).
    * **Readable:** Can be exported as specific rules ("If holds X, Execute Y") using the `--dump-policy 2` flag.

### 2. `sas_plan` (The Optimistic Trace)
* **Type:** **Weak Plan**
* **Description:** This is a linear trace representing **one possible successful execution**. It assumes the robot gets "lucky" on every non-deterministic action (e.g., entering the room succeeds on the first try).
* **Purpose:** PRP generates this first to prove that the goal is *reachable* under best-case conditions. It is used as a skeleton to build the full policy.
* **‚ö†Ô∏è Warning:** Do not use this file for execution in a simulator. It lacks the logic to handle failures or retries.
* **Identifier:** Actions often have suffixes like `_DETDUP_0`, indicating a specific determinized outcome chosen by the planner.

---

## ‚öôÔ∏è Intermediate Pipeline Files

These files are produced by the translation and preprocessing stages. They convert your human-readable PDDL into a mathematical format (Finite-Domain Representation) that the solver can process.

### `output.sas` (The Dictionary)
* **Generated by:** `translate.py`
* **Description:** This file maps your PDDL names to **Numerical Variables**.
* **Usage:** You need this file to decipher the raw policy.
    * *Example:* It translates the cryptic `var34` seen in internal logs to the human-readable `Atom robot-at(curator, maintenance-tunnel)`.

### `output` (The Solver Input)
* **Generated by:** `preprocess`
* **Description:** An optimized, condensed version of `output.sas` with static predicates removed. This is the actual binary/text file fed into the search engine.
* *Note:* In some configurations, this file is moved to the `intermediate_pipeline_files` directory.

---

## üìä Logs & Statistics

### `elapsed.time`
* **Description:** Records the runtime (in seconds) for each phase:
    1.  **Translation:** PDDL $\to$ SAS
    2.  **Preprocessing:** Optimization
    3.  **Search:** Policy Generation

### `plan_numbers_and_cost`
* **Description:** Contains the cost of the *Weak Plan* (`sas_plan`).
* **Note:** It does not represent the cost of the actual Policy, since the Policy could theoretically loop many times before success (infinite horizon), while the Weak Plan assumes 0 failures.

---

## üîÑ PRP Execution Pipeline

The flow of data through the planner is as follows:

1.  **Input:** `domain.pddl` + `problem.pddl`
2.  **Translate:** Generates **`output.sas`** (Variable Mapping).
3.  **Preprocess:** Generates **`output`** (Optimized State Graph).
4.  **Search (PRP):**
    * Finds a **Weak Plan** (`sas_plan`) to guide the search.
    * Simulates execution to find failure states (e.g., stuck in tunnel).
    * Generates rules to recover from those failures (The Retry Loop).
    * Outputs the final **Strong Cyclic Policy** (`policy.out`).